NVL(A,B) : A가 NULL이면 B로 출력
NVL2(A,B,C) : A가 NULL 이 아니면 B를 출력하고 NULL 이면 C 출력
NULLIF(A,B) : A와 B값이 같으면 NULL 출력 다르면 A출력
COALESCE(A,B,C) : A가 있으먄 A출력, A가 없으면 B출력 B도 없으면 C출력




그룹함수에서 NULL 포함시킬려면 NVL 이용

SELECT AVG(NVL(COMMISSION_PCT,0))
FROM EMPLOYEES;


그룹함수 중첩 > 1회만 가능 

SELECT MIN(AVG(SALARY))
FROM EMPOYEES;




JOIN 종류

EQUIJOIN : JOIN 하고자 하는 테이블 양쪽에 같은 특성을 갖는 컬럼이 있을 경우

SELECT EMPLOYEES.EMPLOYEE_ID, EMPLOYEES.DEPARTMENT
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES,DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

3개 이상 테이블 JOIN 시 N-1개의 조인조건 필요 즉 5개 조인시 WHERE절에는 4개의 조건이 있어야된다


NON-EQUIJOIN : JOIN 하고자 하는 테이블 양쪽에 같은 특성을 갖는 컬럼이 없는 경우

SELECT E.LAST)NAME, E.SALARY, J.GRADE_LEVEL
FROM EMPOLOYEES E, JOB_GRADES JOB_GRADES J 
WHERE E.SALARY BETWEEN J.LOWEST_SAL AND J.HIGHEST_SAL;


OUTER JOIN : JOIN 조건에 매칭되지 않는 값도 출력하고자 할때 수행 (+)기호 이용

어느 직원이 어떤 부서에 근무하는지, 부서를 배정받지 않은 직원도 출력 >>더 적은 데이터가 있는 곳에 붙임

SELECT E.EMPLOYEE_IDFROM 
FROM EMPLOYEES E, DEPARTEMENTS D 
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID (+)



SELF JOIN : 하나의 테이블을 두개인 것처럼 두고 수행함 반드시 테이블 별칭 사용

SELECT E.LAST_NAME, M.LAST_NAME
FROM EMPLOYEES E, EMPLOYEES MIN
WHERE E.MANAGER_ID = M.EMPLOYEE_ID;


CROSS JOIN : 두 테이블값을 무조건 조인시

SELECT LAST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES
CROSS JOIN DEPARTMENTS;


NATURAL JOIN(EQUI JOIN) : JOIN 하고자 하는 테이블 양쪽에 같은 특성을 갖는 컬럼이 있고 그 클럼이 같은 경우

SELECT LAST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES
NATURAL JOIN DEPARTMENTS;


위 구문에서 JOIN을 하고자 하는 테이블이 여러개일 경우 USING 사용 이때 USING 절 컬럼 앞에는 테이블 명 붙이지 말것, 데이터 타입은 같어야함

SELECT LAST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES
USING (DEPARTMENT_ID);


위 구문에서 JOIN을 하고자 하는 테이블이 여러개일 경우이지만 컬럼 명이 다른 경우

SELECT LAST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES
ON (DEPARTMENT_ID);

SELECT
FROM
JOIN
ON
JOIN
ON

OUTER JOIN 

    LEFT OUTER JOIN

SELECT E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES EMPLOYEE_ID
LEFT OUTER JOIN DEPARTMENTS DEPARTEMENTS
ON (E.DEPARTMENT_ID = D.DEPARTEMNT_ID)

    RIGHT OUTER JOIN

SELECT E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES EMPLOYEE_ID
RIGHT OUTER JOIN DEPARTMENTS DEPARTEMENTS
ON (E.DEPARTMENT_ID = D.DEPARTEMNT_ID)


    FULL OUTER JOIN

SELECT E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES EMPLOYEE_ID
FULL OUTER JOIN DEPARTMENTS DEPARTEMENTS
ON (E.DEPARTMENT_ID = D.DEPARTEMNT_ID)

--조건 추가

SELECT E.LAST_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES EMPLOYEE_ID
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)
AND E.EMPLOYEE_ID = 100;


서브쿼리 구문

서브쿼리가 메인보다 먼저 수행

SELECT
FROM
WHERE  
            (SELECT
            FROM);

결과값이 하나인 서브쿼리는 단일행 연산자 (=,>,<, <> 등)

결과값이 여러개인 서브쿼리는 다중행 연산자 (IN, < ANY, >ANY, >ALL,< ALL)

WHERE SALARY <ANY  -- JOB_ID = IT_PROG의 어떠한 값보다 작은것,
                (SELECT SALARY
                FROM EMPLOYEES
                WHERE JOB_ID = 'IT_PROG')

WHERE SALARY <ALL  -- JOB_ID = IT_PROG의 모든 값보다 작은것 = 최소값, 그 반대는 최대값
                (SELECT SALARY
                FROM EMPLOYEES
                WHERE JOB_ID = 'IT_PROG')



치환변수

-& : 값의 1회 사용을 위해
-&& : 후속 사용을 위한 치환변수
-DEFINE: 치환변수의 사전 선언시 사용

SELECT 문의 모든 절에 사용가능


SELECT LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY = &SAL;

SELECT LAST_NAME, &SALARY
FROM &EMPLOYEES
WHERE SALARY = &SAL;



SELECT LAST_NAME, SALARY, &&COL 
FROM EMPLOYEES
ORDER BY %COL;

DEFINE V_EMPID = 300

SELECT LAST_NAME, SALARY
FROM EMPLOYEEES
WHERE EMPLOYEE_ID = &V_EMPID ;



INSERT

INSERT INTO 테이블명 (컬럼)
VALUES (데이터값)


테이블의 데이터를 이용하여 다른 테이블에 넣기

INSERT INTO 넣을테이블(1,2,3)
    SELECT 1,2,3
    FROM 테이블명;

VALUES 절을 사용하지 않음
INSERT 절의 컬럼 수와 서브쿼리 SELECT절의 컬럼수가 같아야함



UPDATE

UPDATE 테이블
SET 컬럼 = 값
WHERE 조건



UPDATE
SET 컬럼 = (SELECT
            FROM
            WHERE )

WHERE



DELETE

DELETE 테이블
WHERE 조건



MERGE 
1.테이블 값을 상황에 따라 조건적으로 UPDATE OR INSERT
2.행이 존재할 경우 UPDATE 수행 없을 경우 INSERT 수행



MERGE INTO 테이블명 테이블 별칭
    USING 테이블명(뷰 , 서브쿼리) 별칭
    ON (조인조건)  
    WHERE MATCHED THEN
            UPDATE SET
            컬럼 1 = 값,
            컬럼 2 = 값
    WHEN NOT MATCHED THEN
            INSERT (컬럼명 안써도됨)
            VALUES (값);



MERGE INTO COPY_EMP C 
        USING EMPLOYEES E 
        ON (C.EMPLOYEE_ID = E.EMPLOYEE_ID)
        WHEN MATCHED THEN
            UPDATE SET
            C.FIRST_NAME = E.FIRST_NAME,
            C.LAST_NAME = E.LAST_NAME

        WHEN NOT MATCHED THEN
            INSERT
            VALUES (E.EMPLOYEE_ID, E.FIRST_NAME);



권한 부여

GRANT SELECT
ON TEMP
TO USER1
WITH GRANT OPTION

PUBLIC


REVOKE SELECT
ON TEMP
FROM USER1;




테이블 생성 및 제약조건 PAGE76

CREATE TABLE EMP
    AS SELECT EMPNO, ENAME, JOB HIREDATE
    FROM EMPP
    WHERE DEPTNO=330;





CREATE TABLE TEST_TAB2(
        ID NUMBER,
        PASSWORD VARCHAR2(40)
        CONSRIANTS ID_PK PRIMARY KEY(ID)
    
);




CREATE TABLE EMP_TAB(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    DEPTNO NUMBER(2) NOT NULL
    CONSTRAINT EMP_DEPTNO_FK FOREIGN KEY(DEPTNO)
    REFERENCES DETP(DEPTNO)
);


제약조건 추가

ALTER TABLE EMP
ADD CONSTRAINT EMP_NAME_UK UNIQUE (ENAME);


제약조건 삭제

ALTER TABLE EMP
DROP CONSTRAINT EMP_ENAME_UK;


제약조건 활성화/비활성화

ALTER TABLE EMP
DISABLE/ENABLE CONSTRAINT EMP_PRIMARY_KEY;


제약조건 조회

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='EMP';

SELECT CONSTRAINT_NAME, COLUMN_NAME
FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'EMP';



컬럼추가


ALTER TABLE BONUS
ADD (ETC VARCHAR2(50));


컬럼 수정

ALTER TABLE EMP_30
MODIFY      (ENAME VARCHAR2(15));


컬럼 삭제

ALTER TABLE EMP_30
DROP    (ENAME);


이름 변경

RENAME 기존네임 TO 변경네임


TRUNCATE
테이블 모든 행 삭제, ROLLBAKC 불가

TRUNCATE TABLE 테이블 명


주석

COMMENT ON TABLE 테이블 명 IS '주석';

주석확인 
ALL_COL_COMMENTS
UESR_COL_COMMENTS
ALL_TAB_COMMENTS
USER_TAB_COMMENTS



뷰생성

CREATE VIEW EMP_30
        AS SELECT * 
        FROM EMP
        WHERE DEPTNO = 20;



뷰조회

SELECT * FROM USER_VIEWS;


뷰 수정(ALTER은 사용 불가)

CREATE OR REPLACE VIEW EMP_10 (EMPLOYE_NO, EMPLOYEE_nAME)
        AS SELECT EPNO, ENAME, JOB
        FROM EMP
        WHERE DEPTNO = 10;




WITH CHECK OPTION : 뷰 생성시 제시된 조건에 만족하는 값만 받음


CREATE OR REPLACE VIEW EMP_10 (EMPLOYE_NO, EMPLOYEE_nAME)
        AS SELECT EPNO, ENAME, JOB
        FROM EMP
        WHERE DEPTNO = 10
        WITH CHECK OPTION CONSTRAINT EMP_20_CK;


인라인 뷰 : 1회성 뷰로 FROM절에 작성

SELECT
FROM TEMP A, (SELECT
                FROM
                GROUP BY)

WHERE
AND 



TOP-N분석

가장 크거나 가장 작은 NRO EHCNF
SELECT 컬럼명, ROWNUM
FROM (SELECT 컬럼명
        FROM 테이블명
      ORDER BY TOP-N 컬럼명)
WHERE ROWNUM <= N;


SELECT ROWNUM AS RANK, LAST_NAME, SALARY
FROM (SELECT LAST_NAME, SALARY
        FROM EMPLOYEES
        ORDER BY SALARY DESC)
WHERE ROWNUM <=3;



시퀀스 생성

CREATE SEQUENCE DEPT_DEPTNO
    INCREMENT BY 1
    START WITH 91
    MAXVALUE 99
    NOCACHE
    NOCYCLE;


시퀀스 확인

SELECT SEQUENCE_NAME, MIN_VALUE, MAX_VALUE, ,INCREMENT_BY,LAST_NUMBER
FROM USER_SEQUENCES;



PAGE 96
NEXTVAL : 다음 사용가능한 시퀀스 값
CURRVAL : 현재 시퀀스 값 반환


시퀀스 사용

INSERT INTO DEPT
VALUES (DEPT_DEPTNO.NEXTVAL, '영업부','분당구 정자동');

SELECT DEPT_DEPTNO.CURRVAL
FROM DUAL;


시퀀스 수정
ALTER SEQUENCE 시퀀스명
    이하동일




인덱스 생성

CREATE INDEX EMP_NAME_IDX
ON EMP(ENAME);


인덱스 조회

SELECT C.INDEX_NAME, C.COLUMN_NAME, C.COLUMN_POSITION, I.UNIQUENESS
FROM USER_INDEXES I, USER_IND_COLUMNS C 
WHERE C.INDEX_NAME = I.INDEX_NAME
AND C.TABLE_NAME = 'EMP';



함수기반 인덱스

CREATE INDEX UPPER_EMP_ENAME_IDX
ON EMP(UPPER(ENAME));



시노님 생성 : 객체 이름 제공

CREATE SYNONYM GUBUN
FOR SALGRADE;




SET 연산자 PAGE 106
SELECT문에 등장하는 컬럼의 수와 데이터 타입 일치


UNION : 중복되는 행은 한번만 출력 
UNION ALL : 중복되는 행은 중복 횟수만큼 출력 ,DISTINCT 사용 불가
INTERSECT : 중첩값만 출력, NULL도 반영
MIINUS : 앞 - 뒤 값 뺸것을 출력 WHERE 절에 등장한 컬럼은 반드시 SELECT절에 명시


DATETIME 타임 타입 : PAGE 112

향상된 GROUP BY 절 : PAGE 118

WITH절 : PAGE 135

